setwd("~/GitHub/P7---Cointegration-in-the-cryptocurrency-market/1.Projekt_kode")
source("Tests_in_Code")
#code to bring in the data and refine it into one data frame + check for NA values
source("Projekt_kode_Pull_Crypto.R")
source("Tests_in_Code")
setwd("~/GitHub/P7---Cointegration-in-the-cryptocurrency-market/1.Projekt_kode")
#johansen test
source("Projekt_kode_Pull_Crypto.R")
source("Tests_in_Code")
source("Tests_in_Code.R")
source("Tests_in_Code.R")
summary(Johan.test.crypto)
source("Tests_in_Code.R")
source("Tests_in_Code.R")
# Get Bitcoin data
Crypto<-function(stock,period1,period2){
getSymbols(stock, src = "yahoo", from = period1, to = period2, auto.assign = FALSE)
}
#after the function will the date for the first data be written
#how far you can go back in time from yahoo
Bitcoin<-Crypto("BTC-USD",day_one,"2024-10-10")#2014-09-17
#start dag
day_one<-"2022-10-10" #skal være tidligst 2020-04-10
#after the function will the date for the first data be written
#how far you can go back in time from yahoo
Bitcoin<-Crypto("BTC-USD",day_one,"2024-10-10")#2014-09-17
Ethereum<-Crypto("ETH-USD",day_one,"2024-10-10")#2017-11-09
Solana<-Crypto("SOL-USD",day_one,"2024-10-10")# 2020-04-10
Ripple<-Crypto("XRP-USD",day_one,"2024-10-10")#2017-11-09
#lsit for names of the Cryptos
NameCryptos<-list("Bitcoin","Ethereum","Solana","Ripple")
#cheeks for NA Values and prints out if good or not
for (i in NameCryptos) {
df<-get(i)
if (anyNA(df)) {cat(i,"have NA values")
}
else{cat(i,"is good to go
")
}
}
NameCryptos.adj<-list()
#start dag
day_one<-"2022-10-10" #skal være tidligst 2020-04-10
# Get Bitcoin data
Crypto<-function(stock,period1,period2){
getSymbols(stock, src = "yahoo", from = period1, to = period2, auto.assign = FALSE)
}
#after the function will the date for the first data be written
#how far you can go back in time from yahoo
Bitcoin<-Crypto("BTC-USD",day_one,"2024-10-10")#2014-09-17
Ethereum<-Crypto("ETH-USD",day_one,"2024-10-10")#2017-11-09
Solana<-Crypto("SOL-USD",day_one,"2024-10-10")# 2020-04-10
Ripple<-Crypto("XRP-USD",day_one,"2024-10-10")#2017-11-09
#lsit for names of the Cryptos
NameCryptos<-list("Bitcoin","Ethereum","Solana","Ripple")
#cheeks for NA Values and prints out if good or not
for (i in NameCryptos) {
df<-get(i)
if (anyNA(df)) {cat(i,"have NA values")
}
else{cat(i,"is good to go
")
}
}
#NameCryptos.adj<-list()
#we will now pull out only the adjusted prices for use in Cointegation
for (i in NameCryptos) {
df<-get(i)
assign(paste0(i,".adj"),df[,6])
NameCryptos.adj<-append(NameCryptos.adj,as.character(paste0(i,".adj")))
}
NameCryptos.adj<-list()
#we will now pull out only the adjusted prices for use in Cointegation
for (i in NameCryptos) {
df<-get(i)
assign(paste0(i,".adj"),df[,6])
NameCryptos.adj<-append(NameCryptos.adj,as.character(paste0(i,".adj")))
}
rm(NameCryptos.adj)
NameCryptos.adj<-list()
#we will now pull out only the adjusted prices for use in Cointegation
for (i in NameCryptos) {
df<-get(i)
assign(paste0(i,".adj"),df[,6])
NameCryptos.adj<-append(NameCryptos.adj,as.character(paste0(i,".adj")))
}
for (i in NameCryptos.adj) {
rm(i)
}
for (i in NameCryptos.adj) {
rm(list = i, envir = .GlobalEnv)
}
rm(NameCryptos.adj)
#RULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
#
#
library(quantmod)
#RULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
#
#
library(quantmod)
cat("\033[31mThis text will be printed in red.\033[0m\n")
cat("This text will be printed in red.\033[0m\n")
cat("\033[31mRULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
1. REMOVE ALL EXTRA GLOBAL VARIBELS YOU WONT BE NEEDING AND DONT THINK WILL EVER BE NEEDED
2. DONT YOU  DARE FUCKING TOUCH MY CODE\033[0m\n" )
aov(Crypto.all.adj.pro)
library(urca)
aov(Crypto.all.adj.pro)
View(Crypto.all.adj.pro)
aov(Bitcoin ~ Ethereum)
aov(Bitcoin ~ Ethereum,data=Crypto.all.adj.pro)
summary(ANova_bitcoin)
ANova_bitcoin<-aov(Bitcoin ~ Ethereum, data = Crypto.all.adj.pro)
summary(ANova_bitcoin)
summary(ANova_bitcoin)
plot(ANova_bitcoin$residuals)
plot(ANova_bitcoin$coefficients)
plot(ANova_bitcoin$)
plot(ANova_bitcoin$effects)
plot(ANova_bitcoin$rank)
plot(ANova_bitcoin$fitted.values)
plot(ANova_bitcoin$qr)
plot(ANova_bitcoin$qr$qraux)
plot(ANova_bitcoin$df.residual)
plot(ANova_bitcoin$call)
plot(ANova_bitcoin$terms)
plot(ANova_bitcoin$qr$pivot)
plot(ANova_bitcoin$qr$tol)
plot(ANova_bitcoin$qr$rank)
plot(ANova_bitcoin)
summary(ANova_bitcoin)
ANova_bitcoin<-aov(Bitcoin ~ Ethereum+Ripple, data = Crypto.all.adj.pro)
summary(ANova_bitcoin)
ANova_bitcoin<-aov(Bitcoin ~ Ethereum*Ripple, data = Crypto.all.adj.pro)
summary(ANova_bitcoin)
updateR()
install.packages("installr ")
install.packages("installr")
library(installr)
updateR()
cat("\033[31mRULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
1. REMOVE ALL EXTRA GLOBAL VARIBELS YOU WONT BE NEEDING AND DONT THINK WILL EVER BE NEEDED
2. DONT YOU  DARE FUCKING TOUCH MY CODE\033[0m\n" )
library(quantmod)
library(ggplot2)
library(dplyr)
library(urca)
set.seed(420)#Blaze It
#start dag
day_one<-"2022-10-10" #skal være tidligst 2020-04-10
source("~/GitHub/P7---Cointegration-in-the-cryptocurrency-market/1.Projekt_kode/Projekt_kode_main.R", echo=TRUE)
# Get Bitcoin data
Crypto<-function(stock,period1,period2){
getSymbols(stock, src = "yahoo", from = period1, to = period2, auto.assign = FALSE)
}
#after the function will the date for the first data be written
#how far you can go back in time from yahoo
Bitcoin<-Crypto("BTC-USD",day_one,"2024-10-10")#2014-09-17
Ethereum<-Crypto("ETH-USD",day_one,"2024-10-10")#2017-11-09
Solana<-Crypto("SOL-USD",day_one,"2024-10-10")# 2020-04-10
Ripple<-Crypto("XRP-USD",day_one,"2024-10-10")#2017-11-09
#lsit for names of the Cryptos
NameCryptos<-list("Bitcoin","Ethereum","Solana","Ripple")
#cheeks for NA Values and prints out if good or not
for (i in NameCryptos) {
df<-get(i)
if (anyNA(df)) {cat(i,"have NA values")
}
else{cat(i,"is good to go
")
}
NameCryptos.adj<-list()
#we will now pull out only the adjusted prices for use in Cointegation
for (i in NameCryptos) {
df<-get(i)
assign(paste0(i,".adj"),df[,6])
NameCryptos.adj<-append(NameCryptos.adj,as.character(paste0(i,".adj")))
}
#This saves all the adjusted in one Data Frame
Crypto.all.adj<-NULL
for (i in NameCryptos.adj ){
df<-get(i)
Crypto.all.adj<-cbind(Crypto.all.adj,df)
}
Crypto.all.adj<-as.data.frame(Crypto.all.adj)
#this looks at makes it so we can see it in procentege
Crypto.all.adj.pro<-NULL
for (i in 1:4) {
Crypto.all.adj.pro<-cbind(Crypto.all.adj.pro, (Crypto.all.adj[,i]/Crypto.all.adj[1,i]))
}
Crypto.all.adj.pro<-as.data.frame(Crypto.all.adj.pro)
colnames(Crypto.all.adj.pro)<-NameCryptos
#Removes all extra global variables so it doesn't get to crowded
rm(df)
rm(i)
for (i in NameCryptos.adj) {
rm(list = i, envir = .GlobalEnv)
}
rm(NameCryptos.adj)
library(ggplot2)
library(dplyr)
library(urca)
set.seed(420)#Blaze It
#start dag
day_one<-"2022-10-10" #skal være tidligst 2020-04-10
#code to bring in the data and refine it into one data frame + check for NA values
source("Projekt_kode_Pull_Crypto.R")
source("Tests_in_Code.R")
# Plot priser
ggplot(Crypto.all.adj.pro, aes(1:length(Solana.adj))) +
geom_line(aes(y = Bitcoin, colour = "Bitcoin")) +
geom_line(aes(y = Ethereum, colour = "Ethereum")) +
geom_line(aes(y = Solana, colour = "Solana")) +
geom_line(aes(y = Ripple, colour = "Ripple")) +
labs(x = "Days", y = "Procent") +
scale_color_manual(values = c("Bitcoin" = "red", "Ethereum" = "darkgoldenrod1","Solana"= "Blue","Ripple"="Green"),
labels = NameCryptos,
name = NULL) +
theme(legend.position = "bottom")
summary(ANova_bitcoin)
# Plot priser
ggplot(Crypto.all.adj.pro, aes(1:length(Solana.adj))) +
geom_line(aes(y = Bitcoin, colour = "Bitcoin")) +
geom_line(aes(y = Ethereum, colour = "Ethereum")) +
geom_line(aes(y = Solana, colour = "Solana")) +
geom_line(aes(y = Ripple, colour = "Ripple")) +
labs(x = "Days", y = "Procent") +
scale_color_manual(values = c("Bitcoin" = "red", "Ethereum" = "darkgoldenrod1","Solana"= "Blue","Ripple"="Green"),
labels = NameCryptos,
name = NULL) +
theme(legend.position = "bottom")
#start dag
day_one<-"2022-10-10" #skal være tidligst 2020-04-10
#code to bring in the data and refine it into one data frame + check for NA values
source("Projekt_kode_Pull_Crypto.R")
source("Tests_in_Code.R")
# Plot priser
ggplot(Crypto.all.adj.pro, aes(1:length(Solana.adj))) +
geom_line(aes(y = Bitcoin, colour = "Bitcoin")) +
geom_line(aes(y = Ethereum, colour = "Ethereum")) +
geom_line(aes(y = Solana, colour = "Solana")) +
geom_line(aes(y = Ripple, colour = "Ripple")) +
labs(x = "Days", y = "Procent") +
scale_color_manual(values = c("Bitcoin" = "red", "Ethereum" = "darkgoldenrod1","Solana"= "Blue","Ripple"="Green"),
labels = NameCryptos,
name = NULL) +
theme(legend.position = "bottom")
# Plot priser
ggplot(Crypto.all.adj.pro, aes(1:length(Crypto.all.adj.pro$Bitcoin))) +
geom_line(aes(y = Bitcoin, colour = "Bitcoin")) +
geom_line(aes(y = Ethereum, colour = "Ethereum")) +
geom_line(aes(y = Solana, colour = "Solana")) +
geom_line(aes(y = Ripple, colour = "Ripple")) +
labs(x = "Days", y = "Procent") +
scale_color_manual(values = c("Bitcoin" = "red", "Ethereum" = "darkgoldenrod1","Solana"= "Blue","Ripple"="Green"),
labels = NameCryptos,
name = NULL) +
theme(legend.position = "bottom")
# Plot priser
ggplot(Crypto.all.adj.pro, aes(1:length(Bitcoin))) +
geom_line(aes(y = Bitcoin, colour = "Bitcoin")) +
geom_line(aes(y = Ethereum, colour = "Ethereum")) +
geom_line(aes(y = Solana, colour = "Solana")) +
geom_line(aes(y = Ripple, colour = "Ripple")) +
labs(x = "Days", y = "Procent") +
scale_color_manual(values = c("Bitcoin" = "red", "Ethereum" = "darkgoldenrod1","Solana"= "Blue","Ripple"="Green"),
labels = NameCryptos,
name = NULL) +
theme(legend.position = "bottom")
#hygge ting fordi jeg er er op til at kode
library(urca)
ANova_bitcoin<-aov(Bitcoin ~ Ethereum*Ripple, data = Crypto.all.adj.pro)
summary(ANova_bitcoin)
cat("\033[31mRULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
1. REMOVE ALL EXTRA GLOBAL VARIBELS YOU WONT BE NEEDING AND DONT THINK WILL EVER BE NEEDED
2. DONT YOU  DARE FUCKING TOUCH MY CODE\033[0m\n" )
cat("\033[31mRULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
1. REMOVE ALL EXTRA GLOBAL VARIBELS YOU WONT BE NEEDING AND YOU
DONT THINK EVER WILL BE NEEDED
2. DONT YOU  DARE FUCKING TOUCH MY CODE\033[0m\n" )
library(ggplot2)
cat("\033[31mRULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
1. REMOVE ALL EXTRA GLOBAL VARIBELS YOU WONT BE
NEEDING AND YOU DONT THINK EVER WILL BE NEEDED
2. DONT YOU  DARE FUCKING TOUCH MY CODE\033[0m\n" )
cat("\033[31mRULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
1. REMOVE ALL EXTRA GLOBAL VARIBELS YOU WONT BE
NEEDING AND YOU DONT THINK EVER WILL BE NEEDED
2. DONT YOU  DARE FUCKING TOUCH MY CODE\033[0m\n" )
cat("\033[31mRULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
1. REMOVE ALL EXTRA GLOBAL VARIBELS YOU WONT BE
NEEDING AND YOU DONT THINK EVER WILL BE NEEDED
2. DONT YOU  DARE FUCKING TOUCH MY CODE\033[0m\n" )
NameCryptos.adj<-list()
#we will now pull out only the adjusted prices for use in Cointegation
for (i in NameCryptos) {
df<-get(i)
assign(paste0(i,".adj"),df[,6])
NameCryptos.adj<-append(NameCryptos.adj,as.character(paste0(i,".adj")))
}
View(NameCryptos.adj)
#after the function will the date for the first data be written
#how far you can go back in time from yahoo
Bitcoin<-Crypto("BTC-USD",day_one,"2024-10-10")#2014-09-17
View(Bitcoin)
#Removes all extra global variables so it doesn't get to crowded
rm(df)
rm(i)
for (i in NameCryptos.adj) {
rm(list = i, envir = .GlobalEnv)
}
rm(NameCryptos.adj)
# Plot priser
ggplot(Crypto.all.adj.pro, aes(1:length(Bitcoin))) +
geom_line(aes(y = Bitcoin, colour = "Bitcoin")) +
geom_line(aes(y = Ethereum, colour = "Ethereum")) +
geom_line(aes(y = Solana, colour = "Solana")) +
geom_line(aes(y = Ripple, colour = "Ripple")) +
labs(x = "Days", y = "Procent") +
scale_color_manual(values = c("Bitcoin" = "red", "Ethereum" = "darkgoldenrod1","Solana"= "Blue","Ripple"="Green"),
labels = NameCryptos,
name = NULL) +
theme(legend.position = "bottom")
cat("\033[31mRULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
1. REMOVE ALL EXTRA GLOBAL VARIBELS YOU WONT BE
NEEDING AND YOU DONT THINK EVER WILL BE NEEDED
2. DONT YOU  DARE FUCKING TOUCH MY CODE\033[0m\n" )
library(quantmod)
library(ggplot2)
library(dplyr)
library(urca)
set.seed(420)#Blaze It
#start dag
day_one<-"2022-10-10" #skal være tidligst 2020-04-10
#code to bring in the data and refine it into one data frame + check for NA values
source("Projekt_kode_Pull_Crypto.R")
library(quantmod)
library(ggplot2)
library(dplyr)
library(urca)
set.seed(420)#Blaze It
#start dag
day_one<-"2022-10-10" #skal være tidligst 2020-04-10
#code to bring in the data and refine it into one data frame + check for NA values
source("Projekt_kode_Pull_Crypto.R")
source("Tests_in_Code.R")
cat("\033[31mRULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
1. REMOVE ALL EXTRA GLOBAL VARIBELS YOU WONT BE
NEEDING AND YOU DONT THINK EVER WILL BE NEEDED
2. DONT YOU  DARE FUCKING TOUCH MY CODE\033[0m\n" )
library(quantmod)
library(ggplot2)
library(dplyr)
library(urca)
set.seed(420)#Blaze It
#start dag
day_one<-"2022-10-10" #skal være tidligst 2020-04-10
#code to bring in the data and refine it into one data frame + check for NA values
source("Projekt_kode_Pull_Crypto.R")
cat("\033[31mRULES FOR THE CODE IF YOU WANT TO CHANGE ANYTHING
1. REMOVE ALL EXTRA GLOBAL VARIBELS YOU WONT BE
NEEDING AND YOU DONT THINK EVER WILL BE NEEDED
2. DONT YOU  DARE FUCKING TOUCH MY CODE\033[0m\n" )
library(quantmod)
library(ggplot2)
library(dplyr)
library(urca)
set.seed(420)#Blaze It
#start dag
day_one<-"2022-10-10" #skal være tidligst 2020-04-10
#code to bring in the data and refine it into one data frame + check for NA values
source("Projekt_kode_Pull_Crypto.R")
#Number of lags in our model
install.packages("vars")  # Install the 'vars' package
library(vars)
adf.test(ts_data[, "Crypto.all.adj$BTC.USD.Adjusted"])
install.packages("tseries")
library(tseries)
adf.test(ts_data[, "Crypto.all.adj$BTC.USD.Adjusted"])
#Number of lags in our model
ts_Crypto_all_adj<-ts(Crypto.all.adj)
adf.test(ts_Crypto_all_adj[, "Crypto.all.adj$BTC.USD.Adjusted"])
ts_Crypto_all_adj
adf.test(ts_Crypto_all_adj[, "BTC.USD.Adjusted"])
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 10, type = "const")
print(lag_selection$selection)
print(lag_selection)
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 100, type = "const")
print(lag_selection$selection)
adf.test(ts_Crypto_all_adj[, "BTC.USD.Adjusted"])
adf.test(ts_Crypto_all_adj[, "ETH.USD.Adjusted"])
adf.test(ts_Crypto_all_adj[, "SOL.USD.Adjusted"])
adf.test(ts_Crypto_all_adj[, "XRP.USD.Adjusted"])
colnames(Crypto.all.adj)<-NameCryptos
# Get Bitcoin data
Crypto<-function(stock,period1,period2){
getSymbols(stock, src = "yahoo", from = period1, to = period2, auto.assign = FALSE)
}
#after the function will the date for the first data be written
#how far you can go back in time from yahoo
Bitcoin<-Crypto("BTC-USD",day_one,"2024-10-10")#2014-09-17
Ethereum<-Crypto("ETH-USD",day_one,"2024-10-10")#2017-11-09
Solana<-Crypto("SOL-USD",day_one,"2024-10-10")# 2020-04-10
Ripple<-Crypto("XRP-USD",day_one,"2024-10-10")#2017-11-09
#lsit for names of the Cryptos
NameCryptos<-list("Bitcoin","Ethereum","Solana","Ripple")
#cheeks for NA Values and prints out if good or not
for (i in NameCryptos) {
df<-get(i)
if (anyNA(df)) {cat(i,"have NA values")
}
else{cat(i,"is good to go
")
}
NameCryptos.adj<-list()
#we will now pull out only the adjusted prices for use in Cointegation
for (i in NameCryptos) {
df<-get(i)
assign(paste0(i,".adj"),df[,6])
NameCryptos.adj<-append(NameCryptos.adj,as.character(paste0(i,".adj")))
}
#This saves all the adjusted in one Data Frame
Crypto.all.adj<-NULL
for (i in NameCryptos.adj ){
df<-get(i)
Crypto.all.adj<-cbind(Crypto.all.adj,df)
}
View(Crypto.all.adj)
colnames(Crypto.all.adj)<-NameCryptos
Crypto.all.adj<-as.data.frame(Crypto.all.adj)
NameCryptos[2]
as.character(2983)
str(23)
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 100, type = "const")
print(lag_selection$selection)
plot(lag_selection)
1:4
plot(lag_selection,1:100)
plot(lag_selection,1:length(lag_selection))
#we use AIC and it says 3
length(lag_selection)
View(lag_selection)
lag_selection$criteria
lag_selection$criteria[,1]
lag_selection$criteria[1,]
View(lag_selection$criteria)
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 100, type = "const")
print(lag_selection$selection)
plot(lag_selection$criteria[1,],1:length(lag_selection$criteria[1,]))
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 10, type = "const")
print(lag_selection$selection)
plot(lag_selection$criteria[1,],1:length(lag_selection$criteria[1,]))
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 10, type = "const")
print(lag_selection$selection)
plot(lag_selection$criteria[1,],1:length(lag_selection$criteria[1,]))
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 10, type = "const")
print(lag_selection$selection)
plot(lag_selection$criteria[1,],1:length(lag_selection$criteria[1,]))
lag_selection$criteria[1,]
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 10, type = "const")
library(vars)
library(tseries)
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 10, type = "const")
print(lag_selection$selection)
plot(lag_selection$criteria[1,],1:length(lag_selection$criteria[1,]))
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 10, type = "const")
print(lag_selection$selection)
plot(1:length(lag_selection$criteria[1,]),lag_selection$criteria[1,])
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 100, type = "const")
print(lag_selection$selection)
plot(1:length(lag_selection$criteria[1,]),lag_selection$criteria[1,])
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 1000, type = "const")
print(lag_selection$selection)
plot(1:length(lag_selection$criteria[1,]),lag_selection$criteria[1,])
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 500, type = "const")
print(lag_selection$selection)
plot(1:length(lag_selection$criteria[1,]),lag_selection$criteria[1,])
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 100, type = "const")
print(lag_selection$selection)
plot(1:length(lag_selection$criteria[1,]),lag_selection$criteria[1,])
library(quantmod)
library(ggplot2)
library(dplyr)
library(urca)
library(vars)
library(tseries)
ggplot(lag_selection$criteria, aes(x = 1:length(lag_selection$criteria[1,])),
y = lag_selection$criteria[1,] )
library(vars)
library(tseries)
#Number of lags in our model
lag_selection <- VARselect(ts_Crypto_all_adj, lag.max = 100, type = "const")
print(lag_selection$selection)
ggplot(lag_selection$criteria, aes(x = 1:length(lag_selection$criteria[1,])),
y = lag_selection$criteria[1,] )
lag_selection$criteria
git rm --cached .Rdata
git rm --cached .Rhistory
git rm --cached .Rdata
